names(df.Frec) <- c("Day", "Activity", "Freq.P1", "Freq.P2")
df.Frec <- mutate(df.Frec, Q=(Freq.P1/(Freq.P1+Freq.P2))-(Freq.P2/(Freq.P1+Freq.P2)))
return(df.Frec)
}
crear.ts <- function(df){
# Convert dataframe into a contingency table
df.tbl <- dcast(df, Day ~ Activity, value.var="Q")
# Removing columns with at least one NA value
df.tbl <- select_if(df.tbl[-1] , ~ !any(is.na(.)))
# Removing "0" column
df.tbl <- df.tbl[-1]
# Cleaning inf values
df.tbl <- do.call(data.frame,
lapply(df.tbl, function(x) replace(x, is.infinite(x),NA)))
# Converting houseA into a matrix
df.mat <- as.matrix(df.tbl)
df.ts <- ts(df.mat, start=1, end=30, frequency=1)
return(df.ts)
}
# ImportaciÃ³n de datasets
houseA <- read.csv("data/Modified/houseA_time.csv")
# ImportaciÃ³n de datasets
houseA <- read.csv("data/Time/houseA.csv")
houseB <- read.csv("data/Time/houseB.csv")
#View(houseB.tbl)
#houseB.tbl <- select_if(houseB.tbl[-1] , ~ !any(is.na(.)))
# Removing "0" column
#houseB.tbl <- houseB.tbl[-1]
# Cleaning inf values
#houseA.tbl <- do.call(data.frame,
#                      lapply(houseA.tbl, function(x) replace(x, is.infinite(x),NA)))
# Converting houseA into a matrix
#houseB.mat <- as.matrix(houseB.tbl)
#houseB.ts <- ts(houseB.mat, start=1, end=30)
houseA.Frec <- frec.comp(houseA)
houseA.ts <- crear.ts(houseA.Frec)
plot(na_interpolation(houseA.ts, option="linear"))
head(A)
head(houseA)
str(houseA)
houseA <- mutate(houseA, time=as.POSIXct(time))
houseA <- mutate(houseA, time=as.POSIXct(time)
)
houseA <- mutate(houseA, time=as.POSIXct(time, format="%H:%M:%S"))
head(houseA)
# House A
houseA.Frec <- frec.comp(houseA)
houseA.ts <- crear.ts(houseA.Frec)
plot(na_interpolation(houseA.ts, option="linear"))
plot(na_interpolation(houseA.ts, option="linear"))
head(houseA)
head(houseA.ts)
head(houseA.ts)
head(houseA.Freq)
head(houseA.Frec)
head(houseA)
test <- select(houseA, time, P1, P2)
test
test <- select(houseA, time, P1)
plot(na_interpolation(houseA.ts, option="linear"))
library(zoo)
P <- autoplot(as.zoo(houseA.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
P <- autoplot(as.zoo(houseA.ts), facet=NULL) +
theme_stata() + scale_fill_stata()
#  ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
P
P <- autoplot(as.zoo(houseA.ts$Sleeping), facet=NULL) +
theme_stata() + scale_fill_stata()
P <- autoplot(as.zoo(select(houseA.ts, Day, Sleeping)), facet=NULL) +
theme_stata() + scale_fill_stata()
houseA.ts
P <- autoplot(as.zoo(houseA.ts), facet=NULL) +
theme_stata() + scale_fill_stata()
#  ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
P
t.ts <- select(houseA.ts$Sleeping)
t.ts <- houseA[5]
t.ts
t.ts <- houseA[.5]
t.ts <- houseA[,5]
t.ts
t.ts <- houseA.ts[,5]
t.ts
houseA.ts <- crear.ts(houseA.Frec)
P <- autoplot(as.zoo(t.ts), facet=NULL) +
theme_stata() + scale_fill_stata()
#  ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
P
# LibrerÃ­as
library(dplyr)
library(plyr)
library(purrr)
library(data.table)
library(ggplot2)
library(zoo) # install.packages("zoo")
library(ggthemes) # install.packages("ggthemes")
# Directorio de trabajo
repo.dir <- "C:/Users/luisf/Github/SmartHome-DataAnalytics"
setwd(repo.dir)
# Funciones
# FunciÃ³n para crear una serie univariada
ts.univar <- function(df, actividad, start_, frecuency_) {
# Filtering activity
df <- df[df$Activities==actividad,]
vector <- t(as.vector(select(df, 2:31)))
# Convertimos los datos en serie de tiempo con el comando ts
tsb <- ts(vector,  start=1,  frequency = frecuency_)
# Verificamos Inicio, fin y frecuencia de la serie
start(tsb); end(tsb); frequency(tsb)  # Inicio, fin y frecuencia de la serie
# Regresamos la serie de tiempo
return(tsb)
}
# Funcion para guardar graficas
ts.plot.save <- function(ts1, titulo_, ylab_, xlab_, dir) {
png(paste(dir,".png",sep=''))
P <- autoplot(as.zoo(ts1), facet=NULL) + theme_stata() + scale_fill_stata()  + ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
print(P)
dev.off()
return(P)
}
# Funcion para crear graficas
ts.plot <- function(tss) {
P <- autoplot(as.zoo(tss)/3600, facet=NULL) + theme_stata() + scale_fill_stata()  + ylab('Tiempo acomulado (h)') + xlab('Semana') + ggtitle("Serie de tiempo acomulado por dÃ­a")
return(P)
}
# FunciÃ³n para crear una serie multivariada
ts.multivar <- function(df, activities, start_, frecuency_) {
sdf <- subset(df, Activities %in% activities)
rownames(sdf) <- sdf$Activities
sdf <- select(sdf, 2:31)
sdf <- t(sdf)
# Convertimos los datos en serie de tiempo con el comando ts
tsb <- ts(sdf, start = start_, frequency = frecuency_)
return(tsb)
}
# Buscador de relaciones de actividad por persona en una casa
dash.ts.act <- function(house, person, activity) {
if(house=='A'){
if(person=='P1'){
P1 <- ts.univar(houseA.p1.freq,activity,1,7)
return(ts.plot(P1))
}else if (person=='P2') {
P2 <- ts.univar(houseA.p2.freq,activity,1,7)
return(ts.plot(P2))
}
}
if(house=='B'){
if(person=='P1'){
P1 <- ts.univar(houseB.p1.freq,activity,1,7)
return(ts.plot(P1))
}else if (person=='P2') {
P2 <- ts.univar(houseB.p2.freq,activity,1,7)
return(ts.plot(P2))
}
}
}
# Buscador de relaciones de actividad por persona en una casa
dash.dec.act <- function(house, person, activity) {
if(house=='A'){
if(person=='P1'){
P1 <- ts.univar(houseA.p1.freq,activity,1,7)
return(plot(decompose(P1)))
}else if (person=='P2') {
P2 <- ts.univar(houseA.p2.freq,activity,1,7)
return(plot(decompose(P2)))
}
}
if(house=='B'){
if(person=='P1'){
P1 <- ts.univar(houseB.p1.freq,activity,1,7)
return(plot(decompose(P1)))
}else if (person=='P2') {
P2 <- ts.univar(houseB.p2.freq,activity,1,7)
return(plot(decompose(P2)))
}
}
}
# Buscador de relaciones por casa
dash.ts.act.pers <- function(house,p1, act1, p2, act2) {
if(house=='A'){
if(p1=='P1'){
ts1 <- ts.univar(houseA.p1.freq,act1,1,7)
}else if (p1=='P2') {
ts1 <- ts.univar(houseA.p2.freq,act1,1,7)
}
if(p2=='P1'){
ts2 <- ts.univar(houseA.p1.freq,act2,1,7)
}else if (p2=='P2') {
ts2 <- ts.univar(houseA.p2.freq,act2,1,7)
}
}
if(house=='B'){
if(p1=='P1'){
ts1 <- ts.univar(houseB.p1.freq,act1,1,7)
}else if (p1=='P2') {
ts1 <- ts.univar(houseB.p2.freq,act1,1,7)
}
if(p2=='P1'){
ts2 <- ts.univar(houseB.p1.freq,act2,1,7)
}else if (p2=='P2') {
ts2 <- ts.univar(houseB.p2.freq,act2,1,7)
}
}
return(ts.plot(cbind(ts1,ts2)))
}
## Importamos datos
houseA <- read.csv("data/Time/houseA_time.csv")
houseB <- read.csv("data/Time/houseB_time.csv")
## Serie de actividades por persona por dÃ­a del dÃ­a 1 al 30
houseA.P1.ts.act <- ts(as.vector(t(houseA$X21)), start=1, end=7, frequency=86400)
houseA.P2.ts.act <- ts(as.vector(t(houseA$X22)), start=1, end=7, frequency=86400)
houseB.P1.ts.act <- ts(as.vector(t(houseB$X21)), start=1, end=7, frequency=86400)
houseB.P2.ts.act <- ts(as.vector(t(houseB$X22)), start=1, end=7, frequency=86400)
# Observamos las graficas histÃ³ricas de las actividades por persona
ts.plot.save(houseA.P1.ts.act, "HistÃ³rico actividad casa A persona 1", "Actividad", "Semanas", "houseA-P1-historico")
ts.plot.save(houseA.P2.ts.act, "HistÃ³rico actividad casa A persona 2", "Actividad", "Semanas", "houseA-P2-historico")
ts.plot.save(houseB.P1.ts.act, "HistÃ³rico actividad casa B persona 1", "Actividad", "Semanas", "houseB-P1-historico")
ts.plot.save(houseB.P2.ts.act, "HistÃ³rico actividad casa B persona 2", "Actividad", "Semanas", "houseB-P2-historico")
# Descomponiendo aditivamente las series
ts.plot.save(decompose(houseA.P1.ts.act), "DescomposiciÃ³n aditiva casa A persona 1", "Actividad", "Semanas", "houseA-P1-historico")
ts.plot.save(houseA.P2.ts.act, "HistÃ³rico actividad casa A persona 2", "Actividad", "Semanas", "houseA-P2-historico")
ts.plot.save(houseB.P1.ts.act, "HistÃ³rico actividad casa B persona 1", "Actividad", "Semanas", "houseB-P1-historico")
ts.plot.save(houseB.P2.ts.act, "HistÃ³rico actividad casa B persona 2", "Actividad", "Semanas", "houseB-P2-historico")
## Importamos tablas de frecuencia
houseA.p1.freq <- read.csv("data/Frequency/houseA-p1-freqbyday.csv")
houseA.p2.freq <- read.csv("data/Frequency/houseA-p2-freqbyday.csv")
houseB.p1.freq <- read.csv("data/Frequency/houseB-p1-freqbyday.csv")
houseB.p2.freq <- read.csv("data/Frequency/houseB-p2-freqbyday.csv")
## Importamos tablas de frecuencia
houseA.p1.freq <- read.csv("data/Frequency/houseA-p1-freqbyday.csv")
houseA.p2.freq <- read.csv("data/Frequency/houseA-p2-freqbyday.csv")
houseB.p1.freq <- read.csv("data/Frequency/houseB-p1-freqbyday.csv")
houseB.p2.freq <- read.csv("data/Frequency/houseB-p2-freqbyday.csv")
houseA.p1.freq$Activities
houseB.p1.freq$Activities
# Explorando patrones
dash.ts.act('A','P2','Napping')
dash.ts.act('B','P1','Having Breakfast')
# Descomposicion
dash.dec.act('B','P2',"Toileting")
# Explorando relaciones
dash.ts.act.pers('A','P1',"Toileting", 'P2',"Toileting")
dash.ts.act.pers('B','P1',"Toileting", 'P1','Having Breakfast')
## Serie de tiempo multivariada del tiempo acomulado por actividad por persona
### Actividades por categorÃ­a
aseo         <-   c("Having_Shower", "Toileting","Brushing_Teeth")
salud        <-   c("Sleeping", "Napping", "Toileting")
alimentacion <-   c("Preparing_Breakfast", "Having_Breakfast", "Preparing_Lunch", "Having_Lunch", "Preparing_Dinner", "Having_Dinner", "Having_Snack")
internet     <-   c("Using_Internet")
ludico       <-   c("Watching_TV", "Reading_Book", "Using_Internet")
seguridad    <-   c("\tGoing_Out", "Sleeping", "Napping")
# Estudiando actividades por grupo
ts.plot(ts.multivar(houseA.p1.freq,seguridad,1,7))
ts.plot.save(ts.multivar(houseA.p1.freq,aseo,1,7), "HouseA-P1 activities history", "week", "hour", "houseA-P1-seguridad")
# LibrerÃ­as
library(dplyr)
library(plyr)
library(purrr)
library(data.table)
library(ggplot2)
library(zoo) # install.packages("zoo")
# FunciÃ³n para agregar una columna de dÃ­a
insertar.dia <- function(df, start, end, interval) {
days.nested <- lapply(seq(start,end), rep, interval)
days.flatten <- do.call(c, days.nested)
df <- mutate(df, day=days.flatten)
# Agregar columna de dÃ­a
return(df)
}
# FunciÃ³n para realizar frecuencia acomulada por dÃ­a por persona PROBANDO
freq.tb <- function(col.act, group.by, start, end) {
ds <- tapply(col.act, group.by, FUN = count, simplify = TRUE, default = NA)
ds <- Reduce(function(x,y)merge(x,y,by="x",all=TRUE), ds)
ds[is.na(ds)] <- 0
ds <- as.data.frame(ds)
names(ds) <- c('Activities', seq(start,end))
rownames(ds) <- ds$Activities
return(ds)
}
# FunciÃ³n para realizar frecuencia acomulada por dÃ­a por persona ERROR
freq.tb <- function(col.act, group.by, start, end) {
ds <- tapply(col.act, group.by, FUN = count, simplify = TRUE)
ds <- Map(cbind, ds, seq(start,end))
ds <- rbindlist(lapply(ds, rbind, use.names=FALSE))
ds <- as.data.frame(ds)
ds <- na.omit(ds)
names(ds) <- c('Activities', 'Freq', 'day')
return(ds)
}
# ImportaciÃ³n de datasets
houseA <- read.csv("data/Time/houseA_time.csv")
houseB <- read.csv("data/Time/houseB_time.csv")
# Tablas de frecuencia de actividad del dÃ­a 1 al 30
houseA.p1.freq <- freq.tb(houseA$P1, houseA$day, 1, 30)
houseA.p2.freq <- freq.tb(houseA$P2, houseA$day, 1, 30)
houseB.p1.freq <- freq.tb(houseB$P1, houseA$day, 1, 30)
houseB.p2.freq <- freq.tb(houseB$P2, houseA$day, 1, 30)
setwd("data/Frequency")
write.csv(houseA.p1.freq , file='houseA-p1-freqbyday.csv', row.names=FALSE)
write.csv(houseA.p2.freq , file='houseA-p2-freqbyday.csv', row.names=FALSE)
write.csv(houseB.p1.freq , file='houseB-p1-freqbyday.csv', row.names=FALSE)
write.csv(houseB.p2.freq , file='houseB-p2-freqbyday.csv', row.names=FALSE)
# Directorio de trabajo
repo.dir <- "C:/Users/luisf/Github/SmartHome-DataAnalytics"
setwd(repo.dir)
#Funciones
frec.comp <- function(df){
df.P1 <- table(df$P1, df$Day)
df.P2 <- table(df$P2, df$Day)
df.P1.m <- melt(df.P1)
df.P2.m <- melt(df.P2)
df.Frec <- merge(df.P1.m, df.P2.m, by=c("Var1", "Var2"), all.x=T)
df.Frec <- df.Frec[, c(2,1,3,4)]
names(df.Frec) <- c("Day", "Activity", "Freq.P1", "Freq.P2")
df.Frec <- mutate(df.Frec, Q=(Freq.P1/(Freq.P1+Freq.P2))-(Freq.P2/(Freq.P1+Freq.P2)))
return(df.Frec)
}
crear.ts <- function(df){
# Convert dataframe into a contingency table
df.tbl <- dcast(df, Day ~ Activity, value.var="Q")
# Removing columns with at least one NA value
df.tbl <- select_if(df.tbl[-1] , ~ !any(is.na(.)))
# Removing "0" column
df.tbl <- df.tbl[-1]
# Cleaning inf values
df.tbl <- do.call(data.frame,
lapply(df.tbl, function(x) replace(x, is.infinite(x),NA)))
# Converting houseA into a matrix
df.mat <- as.matrix(df.tbl)
df.ts <- ts(df.mat, start=1, end=30, frequency=7)
return(df.ts)
}
# ImportaciÃ³n de datasets
houseA <- read.csv("data/Time/houseA.csv")
houseB <- read.csv("data/Time/houseB.csv")
houseA <- mutate(houseA, time=as.POSIXct(time, format="%H:%M:%S"))
houseB <- mutate(houseB, time=as.POSIXct(time, format="%H:%M:%S"))
# House A
houseA.Frec <- frec.comp(houseA)
houseA.ts <- crear.ts(houseA.Frec)
(P <- autoplot(as.zoo(houseA.ts), facet=NULL) +
theme_stata() + scale_fill_stata()   )
t.ts <- houseA.ts[,5]
(P <- autoplot(as.zoo(houseA.ts), facet=NULL) +
theme_stata() + scale_fill_stata()   )
(P <- autoplot(as.zoo(t.ts), facet=NULL) +
theme_stata() + scale_fill_stata()   )
#  ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
decompose(t.ts)
#  ylab(ylab_) + xlab(xlab_) + ggtitle(titulo_)
plot(decompose(t.ts))
plot(na_interpolation(houseA.ts, option="linear"))
df.ts <- ts(df.mat, start=1, end=30, frequency=30)
# Converting houseA into a matrix
df.mat <- as.matrix(df.tbl)
# LibrerÃ­as
library(dplyr)
library(tidyr)
library(reshape2)
library(imputeTS)
library(ggthemes)
library(zoo)
# Directorio de trabajo
repo.dir <- "C:/Users/luisf/Github/SmartHome-DataAnalytics"
setwd(repo.dir)
#Funciones
frec.comp <- function(df){
df.P1 <- table(df$P1, df$Day)
df.P2 <- table(df$P2, df$Day)
df.P1.m <- melt(df.P1)
df.P2.m <- melt(df.P2)
df.Frec <- merge(df.P1.m, df.P2.m, by=c("Var1", "Var2"), all.x=T)
df.Frec <- df.Frec[, c(2,1,3,4)]
names(df.Frec) <- c("Day", "Activity", "Freq.P1", "Freq.P2")
df.Frec <- mutate(df.Frec, Q=(Freq.P1/(Freq.P1+Freq.P2))-(Freq.P2/(Freq.P1+Freq.P2)))
return(df.Frec)
}
crear.ts <- function(df){
# Convert dataframe into a contingency table
df.tbl <- dcast(df, Day ~ Activity, value.var="Q")
# Removing columns with at least one NA value
df.tbl <- select_if(df.tbl[-1] , ~ !any(is.na(.)))
# Removing "0" column
df.tbl <- df.tbl[-1]
# Cleaning inf values
df.tbl <- do.call(data.frame,
lapply(df.tbl, function(x) replace(x, is.infinite(x),NA)))
# Converting houseA into a matrix
df.mat <- as.matrix(df.tbl)
df.ts <- ts(df.mat, start=1, end=30, frequency=30)
return(df.ts)
}
houseA <- mutate(houseA, time=as.POSIXct(time, format="%H:%M:%S"))
houseB <- mutate(houseB, time=as.POSIXct(time, format="%H:%M:%S"))
# ImportaciÃ³n de datasets
houseA <- read.csv("data/Time/houseA.csv")
houseB <- read.csv("data/Time/houseB.csv")
houseA <- mutate(houseA, time=as.POSIXct(time, format="%H:%M:%S"))
houseB <- mutate(houseB, time=as.POSIXct(time, format="%H:%M:%S"))
# House A
houseA.Frec <- frec.comp(houseA)
houseA.ts <- crear.ts(houseA.Frec)
plot(na_interpolation(houseA.ts, option="linear"))
crear.ts <- function(df){
# Convert dataframe into a contingency table
df.tbl <- dcast(df, Day ~ Activity, value.var="Q")
# Removing columns with at least one NA value
df.tbl <- select_if(df.tbl[-1] , ~ !any(is.na(.)))
# Removing "0" column
df.tbl <- df.tbl[-1]
# Cleaning inf values
df.tbl <- do.call(data.frame,
lapply(df.tbl, function(x) replace(x, is.infinite(x),NA)))
# Converting houseA into a matrix
df.mat <- as.matrix(df.tbl)
df.ts <- ts(df.mat, start=1, end=30, frequency=4)
return(df.ts)
}
houseA.ts <- crear.ts(houseA.Frec)
(P <- autoplot(as.zoo(t.ts), facet=NULL) +
theme_stata() + scale_fill_stata()   )
#  ylab(ylab_) + xlab(xlab_) + ggtitle(tittle_)
plot(decompose(t.ts))
crear.ts <- function(df){
# Convert dataframe into a contingency table
df.tbl <- dcast(df, Day ~ Activity, value.var="Q")
# Removing columns with at least one NA value
df.tbl <- select_if(df.tbl[-1] , ~ !any(is.na(.)))
# Removing "0" column
df.tbl <- df.tbl[-1]
# Cleaning inf values
df.tbl <- do.call(data.frame,
lapply(df.tbl, function(x) replace(x, is.infinite(x),NA)))
# Converting houseA into a matrix
df.mat <- as.matrix(df.tbl)
df.ts <- ts(df.mat, start=1, end=30, frequency=1)
return(df.ts)
}
# House A
houseA.Frec <- frec.comp(houseA)
houseA.ts <- crear.ts(houseA.Frec)
t.ts <- houseA.ts[,5]
(P <- autoplot(as.zoo(t.ts), facet=NULL) +
theme_stata() + scale_fill_stata()   )
houseA.Frec
houseA.ts
t.ts <- houseA.ts[,1]
t.ts
brush.teetht.ts <- houseA.ts[,1]
(P <- autoplot(as.zoo(brush.teetht.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-")) +
labs(x = "Days", y = "Q"))
tv.ts <- houseA.ts[,10]
(P <- autoplot(as.zoo(tv.ts)), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-")) +
labs(x = "Days", y = "Q"))
(P <- autoplot(as.zoo(tv.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-")) +
labs(x = "Days", y = "Q"))
dishes.ts <-houseA.ts[,9]
(P <- autoplot(as.zoo(dishes.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-")) +
labs(x = "Days", y = "Q"))
plot(decompose(dishes.ts))
plot(na_interpolation(houseA.ts, option="linear"))
plot(na_interpolation(houseA.ts))
plot(na_interpolation(houseA.ts, option="linear"))
plot(na_interpolation(houseA.ts, option="linear"))+
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-"))
plot(na_interpolation(houseA.ts, option="linear")) +
theme_stata() + scale_fill_stata()  + ggtitle(paste("Time series of Q-"))
(P <- autoplot(as.zoo(na_interpolation(houseA.ts, option="linear")), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-")) +
labs(x = "Days", y = "Q"))
plot(na_interpolation(houseB.ts, option="linear"))
houseB.Frec <- frec.comp(houseB)
houseB.ts <- crear.ts(houseB.Frec)
plot(na_interpolation(houseB.ts, option="linear"))
ggsave("Q_houseA.png")
plot(na_interpolation(houseB.ts, option="linear"))
plot(na_interpolation(houseB.ts, option="linear"))
(P <- autoplot(as.zoo(dishes.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q-")) +
labs(x = "Days", y = "Q"))
(P <- autoplot(as.zoo(tv.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q - Watching tv")) +
labs(x = "Days", y = "Q"))
ggsave("A_tv_ts.png")
dishes.ts <-houseA.ts[,9]
(P <- autoplot(as.zoo(dishes.ts), facet=NULL) +
theme_stata() + scale_fill_stata()  +
ggtitle(paste("Time series of Q - Washing dishes")) +
labs(x = "Days", y = "Q"))
ggsave("A_dishes_ts.png")
plot(na_interpolation(houseB.ts, option="linear"))
ggsave("Q_houseA.png")
plot(na_interpolation(houseB.ts, option="linear"))
ggsave("Q_houseB.png")
plot(na_interpolation(houseA.ts, option="linear"))
ggsave("Q_houseA.png")
plot(na_interpolation(houseB.ts, option="linear"))
ggsave("Q_houseB.png")
